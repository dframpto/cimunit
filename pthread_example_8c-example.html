<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CIMUnit: pthread_example.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CIMUnit&#160;<span id="projectnumber">1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">pthread_example.c</div>  </div>
</div>
<div class="contents">
<p>This example runs under pthreads and provides a detailed walkthrough of how CIMUnit operates to perform the appropriate testing.</p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright 2011 Dale Frampton and Kurtis Nusbaum</span>
<span class="comment"> * </span>
<span class="comment"> * This file is part of cimunit.</span>
<span class="comment"> * </span>
<span class="comment"> * cimunit is free software: you can redistribute it and/or modify</span>
<span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<span class="comment"> * the Free Software Foundation, either version 2 of the License, or</span>
<span class="comment"> * (at your option) any later version.</span>
<span class="comment"> * </span>
<span class="comment"> * cimunit is distributed in the hope that it will be useful,</span>
<span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment"> * GNU General Public License for more details.</span>
<span class="comment"> * </span>
<span class="comment"> * You should have received a copy of the GNU General Public License</span>
<span class="comment"> * along with cimunit.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;assert.h&gt;</span>
<span class="preprocessor">#include &lt;pthread.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="preprocessor">#include &quot;<a class="code" href="cimunit_8h.html">cimunit.h</a>&quot;</span>


<span class="comment">/*******************************</span>
<span class="comment">  Begin Software Under Test</span>
<span class="comment">*******************************/</span>


<span class="comment">// Structure defining an element within a concurrent queue.</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>queue_element{
  <span class="comment">// The actual int value that&#39;s queued.</span>
  <span class="keywordtype">int</span> value;
  
  <span class="comment">// A pointer pointing to the next element in the queue.</span>
  <span class="keyword">struct </span>queue_element *next;
} queue_element_t;


<span class="comment">// Structure defining a concurrent queue</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>{

  <span class="comment">// A pointer that points to the head of the queue. NULL if there are </span>
  <span class="comment">// no items in the queue.</span>
  queue_element_t *head;

  <span class="comment">// A pointer that points to the tail of the queueu. NULL if there are</span>
  <span class="comment">// no items in the queue.</span>
  queue_element_t *tail;

  <span class="comment">// A mutex that protects critical sections in queue related code that </span>
  <span class="comment">// modifies the queue.</span>
  pthread_mutex_t modify_mutex;

  <span class="comment">// The number of elements in the queue.</span>
  <span class="keywordtype">size_t</span> size;
} concurrent_queue_t;


<span class="comment">// Initalizes an element for a queue.</span>
<span class="comment">//</span>
<span class="comment">// \param element - The queue element to be initialized</span>
<span class="comment">// \param element - The value which the element shall hold.</span>
<span class="keywordtype">void</span> queue_element_init(queue_element_t *element, <span class="keywordtype">int</span> value);
  
<span class="comment">// Initializes a concurrent queue.</span>
<span class="comment">//</span>
<span class="comment">// \param queue - The queue to be initialized</span>
<span class="keywordtype">void</span> concurrent_queue_init(concurrent_queue_t *queue);

<span class="comment">// Frees all alocated resources for concurrent queue.</span>
<span class="comment">//</span>
<span class="comment">// \param queue - The queue to be destroyed.</span>
<span class="keywordtype">void</span> concurrent_queue_destroy(concurrent_queue_t *queue);

<span class="comment">// Enqueues a value in the given concurrent queue.</span>
<span class="comment">//</span>
<span class="comment">// \param queue - The queue into which the value shall be enqueue.</span>
<span class="comment">// \param value - The value to enqueue.</span>
<span class="keywordtype">void</span> concurrent_queue_enqueue(concurrent_queue_t *queue, <span class="keywordtype">int</span> value);

<span class="comment">// Dequeus the next element from the queue.</span>
<span class="comment">//</span>
<span class="comment">// \param queue - The queue from which a value should be dequeued.</span>
<span class="comment">// \param value - A pointer into which the value of the dequeued element is</span>
<span class="comment">//  stored. If no element is dequeued, the value remains unchanged.</span>
<span class="comment">// \return - 0 if an element was successfully dequeued. If the queue</span>
<span class="comment">//  was empty and therefore nothing was dequeued, this funciton returns 1.</span>
<span class="keywordtype">int</span> concurrent_queue_dequeue(concurrent_queue_t *queue, <span class="keywordtype">int</span> *value);

<span class="comment">// Gets the size of a queue.</span>
<span class="comment">//</span>
<span class="comment">// \param queue - The queue whose size is desired.</span>
<span class="comment">// \param value - A pointer into which the size of the queue will be stored.</span>
<span class="keywordtype">void</span> concurrent_queue_size(concurrent_queue_t *queue, <span class="keywordtype">size_t</span> *size);


<span class="keywordtype">void</span> queue_element_init(queue_element_t *element, <span class="keywordtype">int</span> value){
  element-&gt;value = value;
}


<span class="keywordtype">void</span> concurrent_queue_init(concurrent_queue_t *queue){
  pthread_mutex_init(&amp;(queue-&gt;modify_mutex), NULL); 
  queue-&gt;head = NULL;
  queue-&gt;tail = NULL;
  queue-&gt;size = 0;
}


<span class="keywordtype">void</span> concurrent_queue_destroy(concurrent_queue_t *queue){
  queue_element_t *current_element = queue-&gt;head;
  <span class="keywordflow">while</span>(current_element != NULL){
    queue_element_t *temp = current_element;
    current_element = current_element-&gt;next;
    free(temp); 
  }
  pthread_mutex_destroy(&amp;(queue-&gt;modify_mutex));
}


<span class="keywordtype">void</span> concurrent_queue_enqueue(concurrent_queue_t *queue, <span class="keywordtype">int</span> value){
  queue_element_t *new_element = 
    (queue_element_t*)malloc(<span class="keyword">sizeof</span>(queue_element_t));
  new_element-&gt;value = value;
  new_element-&gt;next = NULL;
  pthread_mutex_lock(&amp;(queue-&gt;modify_mutex));
  <span class="keywordflow">if</span>(queue-&gt;head == NULL){
    queue-&gt;head = new_element;
    queue-&gt;tail = new_element;
  }
  <span class="keywordflow">else</span>{
    queue-&gt;tail-&gt;next = new_element;
  }
  queue-&gt;size++;
  pthread_mutex_unlock(&amp;(queue-&gt;modify_mutex));
}


<span class="keywordtype">int</span> concurrent_queue_dequeue(concurrent_queue_t *queue, <span class="keywordtype">int</span> *value){
  queue_element_t *dequed_element = NULL;
  pthread_mutex_lock(&amp;(queue-&gt;modify_mutex));
  <span class="keywordflow">if</span>(queue-&gt;size &gt; 0){
    dequed_element = queue-&gt;head;
    queue-&gt;head = queue-&gt;head-&gt;next;
    queue-&gt;size--;
  }
  pthread_mutex_unlock(&amp;(queue-&gt;modify_mutex));

  <span class="keywordflow">if</span>(dequed_element != NULL){
    *value = dequed_element-&gt;value;
    free(dequed_element);
    <span class="keywordflow">return</span> 0;
  }
  <span class="keywordflow">else</span>{
    <span class="keywordflow">return</span> 1;
  }
}


<span class="keywordtype">void</span> concurrent_queue_size(concurrent_queue_t *queue, <span class="keywordtype">size_t</span> *value){
  pthread_mutex_lock(&amp;(queue-&gt;modify_mutex));
  *value  = queue-&gt;size;
  pthread_mutex_unlock(&amp;(queue-&gt;modify_mutex));
}


<span class="comment">/*******************************</span>
<span class="comment">  Begin Test Code</span>
<span class="comment">*******************************/</span>


<span class="comment">// This is a structure we will use to pass arguements to our thread </span>
<span class="comment">// functions. Don&#39;t worry about it just yet.</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
  <a name="_a0"></a><a class="code" href="structcimunit__schedule.html" title="Structure use to define a CIMUnit schedule.">cimunit_schedule_t</a> *schedule;
  concurrent_queue_t *queue;
  <span class="keywordtype">int</span> dequeued_value;
  <span class="keywordtype">int</span> dequeue_return_val;
} thread_args_t;


<span class="comment">// More on these later...</span>
<span class="keywordtype">void</span> *consumer_function(<span class="keywordtype">void</span> *args);
<span class="keywordtype">void</span> *producer_function(<span class="keywordtype">void</span> *args);


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]){
  <span class="comment">/*</span>
<span class="comment">   * Welcome to CIMUnit, the multithreading testing framework. We&#39;re going</span>
<span class="comment">   * to do a quick simple example for you here to help get you started.</span>
<span class="comment">   * Nothing to complicated. Just something to show you how to use some of </span>
<span class="comment">   * the basic features of CIMUnit.</span>
<span class="comment">   */</span>

  <span class="comment">/*</span>
<span class="comment">   * In this example we&#39;re going to be testing a basic concurrent queue </span>
<span class="comment">   * structure we&#39;ve put together. This data strcuture is a basic queue that </span>
<span class="comment">   * allow for multiple threads to queue and dequeue elements from it in a safe </span>
<span class="comment">   * manner. There&#39;s an important feature of our queue to note: if one thread</span>
<span class="comment">   * attempts to dequeue an element from the queue and the queue is empty, </span>
<span class="comment">   * the dequeue funtion will return an error code. Don&#39;t worry about this</span>
<span class="comment">   * too much now, but it&#39;s a little detail that&#39;s going to come up later.</span>
<span class="comment">   * If you want more about the implementation details of this concurrent queue,</span>
<span class="comment">   * feel free to take a look at the concurrent_queue.(h|c) files. </span>
<span class="comment">   */</span>

  <span class="comment">/*</span>
<span class="comment">   * CIMUnit is flexible and can be integrated into your testing framework of</span>
<span class="comment">   * choice. For this example though, we&#39;re just going to use a simple error</span>
<span class="comment">   * variable to keep track of any testing failures.</span>
<span class="comment">   */</span>
  <span class="keywordtype">int</span> error = 0;

  <span class="comment">/* </span>
<span class="comment">   * Here we&#39;re going to declare and initialize the queue we want to use.</span>
<span class="comment">   */</span>
  concurrent_queue_t queue;
  concurrent_queue_init(&amp;queue);
   

  <span class="comment">/*</span>
<span class="comment">   * Our test is going to consist of two threads. One, the producuer, will be</span>
<span class="comment">   * adding an element to the queue. The other, the consumer, will be </span>
<span class="comment">   * dequeuing an item from the queue. For our first test, we just want to</span>
<span class="comment">   * ensure that everything works out nicely as long as our producer thread</span>
<span class="comment">   * enqueues a value before our consumer thread does a dequeue. In CIMUnit,</span>
<span class="comment">   * we can enforce thread schedules using a schedule data strucuture. When</span>
<span class="comment">   * initializing this data structure, we pass a string representing our</span>
<span class="comment">   * desired schedule. In this case, we want to ensure that we start our </span>
<span class="comment">   * dequeue only after we end our enqueue. All of this is accomplished using</span>
<span class="comment">   * the simple line of code below.</span>
<span class="comment">   */</span>
  <a class="code" href="structcimunit__schedule.html" title="Structure use to define a CIMUnit schedule.">cimunit_schedule_t</a> *schedule = <a name="a1"></a><a class="code" href="group__cimunit__schedule.html#ga61ff8f64cc0c3cda683e87e92043a73c">cimunit_schedule_parse</a>(
    <span class="stringliteral">&quot;end_enqueue1-&gt;start_dequeue1&quot;</span>);

  <span class="comment">/*</span>
<span class="comment">   * CIMUnit schedules are comprised mostly of what are called &quot;events&quot;. </span>
<span class="comment">   * CIMUnit schedules enforce particular threading schedules by ensuring that</span>
<span class="comment">   * a certain sequence of events occur. The schedule </span>
<span class="comment">   * &quot;endequeue1-&gt;startdequeue1&quot; says that the &quot;endenqueue1&quot; event must</span>
<span class="comment">   * occur before the &quot;startdequeue1&quot; event occurs.</span>
<span class="comment">   *</span>
<span class="comment">   * Now, you may be saying to yourself, &quot;Hey bub, how does the schedule know</span>
<span class="comment">   * when my enqueue has ended and my dequeue has started?&quot; Well, take a quick</span>
<span class="comment">   * look down at our producer and consumer funcitons. You&#39;ll notice that </span>
<span class="comment">   * we&#39;ve passed our schedule object down into them and we &quot;fire&quot; off events</span>
<span class="comment">   * to let the schedule know certain events have occurred.</span>
<span class="comment">   */</span>


  <span class="comment">/* </span>
<span class="comment">   * Here we&#39;re just packing up the arguments that we want to send to each</span>
<span class="comment">   * of our thread functions. Note that we&#39;re passing the schedule to the</span>
<span class="comment">   * funcitons. This is so we can fire off events as described above. As a </span>
<span class="comment">   * generall rule of thumb, you&#39;re pretty much always going to want to be </span>
<span class="comment">   * passing the schedule to your thread functions.</span>
<span class="comment">   */</span>
  thread_args_t args;
  args.queue = &amp;queue;
  args.schedule = schedule;
  args.dequeued_value = 0;
  args.dequeue_return_val = 0;

  <span class="comment">/*</span>
<span class="comment">   * Here we create and launch our threads using standard pthreads functions.</span>
<span class="comment">   */</span>
  pthread_t producer_thread;
  pthread_t consumer_thread;
  pthread_create(&amp;producer_thread, NULL, producer_function, (<span class="keywordtype">void</span>*)(&amp;args));
  pthread_create(&amp;consumer_thread, NULL, consumer_function, (<span class="keywordtype">void</span>*)(&amp;args));

  <span class="comment">/*</span>
<span class="comment">   * Here we ensure that our threads have terminated using standard pthreads</span>
<span class="comment">   * functions.</span>
<span class="comment">   */</span>
  pthread_join(producer_thread, NULL);
  pthread_join(consumer_thread, NULL);

  <span class="comment">/*</span>
<span class="comment">   * Ok, our thread functions ran. What just happened? Well if you take </span>
<span class="comment">   * another peek down at the thread functions you&#39;ll see that if our</span>
<span class="comment">   * schedule was enforces properly, the enqueue function should have</span>
<span class="comment">   * first enqueued a &quot;5&quot; and then our consumer function should have dequeued</span>
<span class="comment">   * the &quot;5&quot;. If our concurrent queue structure functioned the way it should</span>
<span class="comment">   * have, we should now have args.dequeued_value set to 5, </span>
<span class="comment">   * the dequeue_return_val set set to 0, and the queue size be equal to zero.</span>
<span class="comment">   *  This is what we check below. When you run this executable, hopefully </span>
<span class="comment">   * your get the message that the test passed!</span>
<span class="comment">   */</span>
  <span class="keywordtype">size_t</span> queue_size;
  concurrent_queue_size(&amp;queue, &amp;queue_size);
  <span class="keywordflow">if</span>(args.dequeued_value == 5 &amp;&amp;
     args.dequeue_return_val == 0 &amp;&amp;
     queue_size == 0)
  {
    printf(<span class="stringliteral">&quot;Test 1 passed :)\n&quot;</span>);
  }
  <span class="keywordflow">else</span>{
    fprintf(stderr, <span class="stringliteral">&quot;Test 1 failed!\n&quot;</span>);
    fprintf(stderr, <span class="stringliteral">&quot;Dequeued value was: %d\n&quot;</span>, args.dequeued_value);
    fprintf(stderr, <span class="stringliteral">&quot;Dequeue return value was: %d\n&quot;</span>, args.dequeue_return_val);
    fprintf(stderr, <span class="stringliteral">&quot;Size was: %zu\n&quot;</span>, queue_size);
    error +=1;
  }

  <span class="comment">/*</span>
<span class="comment">   * Before finishing up this test, we destroy the schedule and the queue.</span>
<span class="comment">   */</span>
  <a name="a2"></a><a class="code" href="group__cimunit__schedule.html#ga72f4771cf3b96241da1791e3fabb14b7" title="Destroy the schedule object and free memory.">cimunit_schedule_destroy</a>(schedule);
  concurrent_queue_destroy(&amp;queue);


  <span class="comment">/*</span>
<span class="comment">   * One of the cool things about CIMUnit is that you can test the same set</span>
<span class="comment">   * of functions with a differnet thread schedule. The idea is that you</span>
<span class="comment">   * shouldn&#39;t have to write essentially identical functions just to test </span>
<span class="comment">   * different thread schedules. Let&#39;s try testing some different functionaliy</span>
<span class="comment">   * this time around. Remember how we told you that if you try to dequeue </span>
<span class="comment">   * something from an empty queue, you&#39;re not going to get anything out and the</span>
<span class="comment">   * dequeue function should return an error code? We&#39;ll let&#39;s see if we can</span>
<span class="comment">   * verify this behavior. Let&#39;s create a new schedule were we finish our</span>
<span class="comment">   * dequeue attempt before the enqueue starts.</span>
<span class="comment">   */</span>
  schedule = <a class="code" href="group__cimunit__schedule.html#ga61ff8f64cc0c3cda683e87e92043a73c">cimunit_schedule_parse</a>(<span class="stringliteral">&quot;end_dequeue1-&gt;start_enqueue1&quot;</span>);
 
  <span class="comment">/*</span>
<span class="comment">   * Once again, we&#39;ll initilize our queue and the values for the arguements</span>
<span class="comment">   * we&#39;re going to pass to each of our threading funcitons.</span>
<span class="comment">   */</span>
  concurrent_queue_init(&amp;queue);
  args.dequeued_value=0;
  args.dequeue_return_val = 0;
  args.schedule = schedule;
  
  <span class="comment">/*</span>
<span class="comment">   * We then create, launch, and join our threads using the standard pthread</span>
<span class="comment">   * funcitons just like before.</span>
<span class="comment">   */</span>
  pthread_create(&amp;producer_thread, NULL, producer_function, (<span class="keywordtype">void</span>*)(&amp;args));
  pthread_create(&amp;consumer_thread, NULL, consumer_function, (<span class="keywordtype">void</span>*)(&amp;args));
  pthread_join(producer_thread, NULL);
  pthread_join(consumer_thread, NULL);


  <span class="comment">/*</span>
<span class="comment">   * Alright, so what should have happened? If our schedule was enforced and</span>
<span class="comment">   * the concurrent queue functioned as specified, we should have attempted</span>
<span class="comment">   * to dequeue before anything was ever equeued in the queue. This should</span>
<span class="comment">   * result in our dequeued value not chaning from 0, the return value from</span>
<span class="comment">   * the dequeue funciton not being 0 (it&#39;s an error code), and the queue</span>
<span class="comment">   * size now being one because we did after all actually enqueue an element.</span>
<span class="comment">   * The code below verifies this and if you run this test you should see </span>
<span class="comment">   * that it passed.</span>
<span class="comment">   */</span>

  concurrent_queue_size(&amp;queue, &amp;queue_size);
  <span class="keywordflow">if</span>(args.dequeued_value == 0 &amp;&amp; 
     args.dequeue_return_val != 0 &amp;&amp;
     queue_size == 1)
  {
    printf(<span class="stringliteral">&quot;Test 2 passed :)\n&quot;</span>);
  }
  <span class="keywordflow">else</span>{
    fprintf(stderr, <span class="stringliteral">&quot;Test 2 failed!\n&quot;</span>);
    fprintf(stderr, <span class="stringliteral">&quot;Dequeued value was: %d\n&quot;</span>, args.dequeued_value);
    fprintf(stderr, <span class="stringliteral">&quot;Dequeue return value was: %d\n&quot;</span>, args.dequeue_return_val);
    fprintf(stderr, <span class="stringliteral">&quot;Size was: %zu\n&quot;</span>, queue_size);
    error +=1;
  }

  <span class="comment">/*</span>
<span class="comment">   * Once again, we now destroy the schedule and queue objects.</span>
<span class="comment">   */</span>
  <a class="code" href="group__cimunit__schedule.html#ga72f4771cf3b96241da1791e3fabb14b7" title="Destroy the schedule object and free memory.">cimunit_schedule_destroy</a>(schedule);
  concurrent_queue_destroy(&amp;queue);
  
  <span class="comment">/*</span>
<span class="comment">   * That&#39;s about it. If there were any errors (which there shouldn&#39;t have been)</span>
<span class="comment">   * our return value would be non-zero. Once agin, CIMUnit is flexible</span>
<span class="comment">   * enough that you can use your testing framework of choice to verify test</span>
<span class="comment">   * results, we just used a simple int to store our errors for simplicity&#39;s </span>
<span class="comment">   * sake. This has been just a basic example of how to use CIMUnit.</span>
<span class="comment">   * If you&#39;re interested in learning more, checkout some of our more </span>
<span class="comment">   * complicated examples.</span>
<span class="comment">   */</span>
  <span class="keywordflow">return</span> error;
}


<span class="comment">// Consumer thread funciton</span>
<span class="keywordtype">void</span> *consumer_function(<span class="keywordtype">void</span> *args){
  thread_args_t *thread_args = (thread_args_t*)args;
  concurrent_queue_t *queue = thread_args-&gt;queue;
  <a class="code" href="structcimunit__schedule.html" title="Structure use to define a CIMUnit schedule.">cimunit_schedule_t</a> *schedule = thread_args-&gt;schedule;

  <span class="comment">/*</span>
<span class="comment">   * Inform the schedule that we&#39;ve begun attempting to dequeue an element.</span>
<span class="comment">   */</span>
  <a name="a3"></a><a class="code" href="group__cimunit__schedule.html#ga51236ae0abd30f98baa140eed1ab7a3c">cimunit_schedule_fire</a>(schedule, <span class="stringliteral">&quot;start_dequeue1&quot;</span>);
  thread_args-&gt;dequeue_return_val = 
    concurrent_queue_dequeue(queue, &amp;(thread_args-&gt;dequeued_value));
  <span class="comment">/*</span>
<span class="comment">   * Inform the schedule that we&#39;ve finished attempting to dequeue an element.</span>
<span class="comment">   */</span>
  <a class="code" href="group__cimunit__schedule.html#ga51236ae0abd30f98baa140eed1ab7a3c">cimunit_schedule_fire</a>(schedule, <span class="stringliteral">&quot;end_dequeue1&quot;</span>);
}


<span class="comment">// Producer thread funciton</span>
<span class="keywordtype">void</span> *producer_function(<span class="keywordtype">void</span> *args){
  thread_args_t *thread_args = (thread_args_t*)args;
  concurrent_queue_t *queue = thread_args-&gt;queue;
  <a class="code" href="structcimunit__schedule.html" title="Structure use to define a CIMUnit schedule.">cimunit_schedule_t</a> *schedule = thread_args-&gt;schedule;
  
  <span class="comment">/*</span>
<span class="comment">   * Inform the schedule that we&#39;ve begun enquue an element.</span>
<span class="comment">   */</span>
  <a class="code" href="group__cimunit__schedule.html#ga51236ae0abd30f98baa140eed1ab7a3c">cimunit_schedule_fire</a>(schedule, <span class="stringliteral">&quot;start_enqueue1&quot;</span>);
  concurrent_queue_enqueue(queue, 5);
  <span class="comment">/*</span>
<span class="comment">   * Inform the schedule that we&#39;ve finished enquueing an element.</span>
<span class="comment">   */</span>
  <a class="code" href="group__cimunit__schedule.html#ga51236ae0abd30f98baa140eed1ab7a3c">cimunit_schedule_fire</a>(schedule, <span class="stringliteral">&quot;end_enqueue1&quot;</span>);
}

</pre></div> </div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated for CIMUnit by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4</small></address>

</body>
</html>
