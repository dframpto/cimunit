<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CIMUnit: vxworks_example.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CIMUnit&#160;<span id="projectnumber">1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">vxworks_example.cpp</div>  </div>
</div>
<div class="contents">
<p>This example runs under VxWorks and shows a templatized stack class that is intended to be thread safe. The class is tested in a number of different manners, culmanting with a white box test using CIMUnit. The white box test is the only one that consistently detects a race condition in the code if the mutexes around the pop() method are not in-place.</p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// cimunit_example.cpp</span>
<span class="comment">//</span>
<span class="comment">// Copyright 2011 Dale Frampton and Kurtis Nusbaum</span>
<span class="comment">// </span>
<span class="comment">// This file is part of cimunit.</span>
<span class="comment">// </span>
<span class="comment">// cimunit is free software: you can redistribute it and/or modify</span>
<span class="comment">// it under the terms of the GNU General Public License as published by</span>
<span class="comment">// the Free Software Foundation, either version 2 of the License, or</span>
<span class="comment">// (at your option) any later version.</span>
<span class="comment">// </span>
<span class="comment">// cimunit is distributed in the hope that it will be useful,</span>
<span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment">// GNU General Public License for more details.</span>
<span class="comment">// </span>
<span class="comment">// You should have received a copy of the GNU General Public License</span>
<span class="comment">// along with cimunit.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="comment">// </span>

<span class="preprocessor">#include &lt;vxworks.h&gt;</span>
<span class="preprocessor">#include &lt;deque&gt;</span>
<span class="preprocessor">#include &lt;semLib.h&gt;</span>
<span class="preprocessor">#include &lt;stdexcept&gt;</span>
<span class="preprocessor">#include &lt;taskLib.h&gt;</span>

<span class="preprocessor">#include &quot;<a class="code" href="cimunit_8h.html">cimunit.h</a>&quot;</span>
<span class="preprocessor">#include &quot;cppunit/extensions/HelperMacros.h&quot;</span>

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">class </span>ThreadStack {
  <span class="keyword">public</span>:
    ThreadStack() {
      m_mutex = semMCreate(SEM_Q_FIFO); 
      <span class="keywordflow">if</span> (!m_mutex) {
        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unable to create mutex&quot;</span>);
      }
    };
    
    <span class="keywordtype">void</span> push(T item) {
      semTake(m_mutex, WAIT_FOREVER);
      m_container.push_front(item);
      semGive(m_mutex);
    }
    
    T pop() {
      semTake(m_mutex, WAIT_FOREVER);
      T item = m_container.front();
      <a name="a0"></a><a class="code" href="group__cimunit.html#gac71b8001526bea0ad3cec09dacec617e">CIMUNIT_FIRE</a>(<span class="stringliteral">&quot;TS::pop/1&quot;</span>);
      m_container.pop_front();
      semGive(m_mutex);
      <span class="keywordflow">return</span> item;
    }
    
    <span class="keywordtype">bool</span> empty() {
      semTake(m_mutex, WAIT_FOREVER);
      <span class="keywordtype">bool</span> result = m_container.empty();
      semGive(m_mutex);
      <span class="keywordflow">return</span> result;
    }
    
  <span class="keyword">private</span>:
    std::deque&lt;T&gt; m_container;
    SEM_ID m_mutex;
    
  
};


<span class="comment">// Example of using CIMUnit under VxWorks</span>
<span class="keyword">class </span>CimunitExample : <span class="keyword">public</span> CppUnit::TestFixture
{
  CPPUNIT_TEST_SUITE(CimunitExample);
  CPPUNIT_TEST(singleThreaded);
  CPPUNIT_TEST(multiThreadedStress);
  CPPUNIT_TEST(cimunitStressTest);
  CPPUNIT_TEST(cimunitWhiteBoxTest);
  CPPUNIT_TEST_SUITE_END();

<span class="keyword">public</span>:
  <span class="comment">// Initializes the loopback driver and the driver interface void setUp();</span>
  <span class="keywordtype">void</span> setUp();

  <span class="comment">// Removes the driver interface and disables the loopback driver </span>
  <span class="keywordtype">void</span> tearDown();

  <span class="comment">// Single threaded test used to show proper operation of stack in a single</span>
  <span class="comment">// threaded environment.</span>
  <span class="keywordtype">void</span> singleThreaded();
  
  <span class="comment">// Stress test used to show proper operation of the stack in a</span>
  <span class="comment">// multithreaded environment.  This test doesn&#39;t use CIMUnit.</span>
  <span class="comment">//</span>
  <span class="comment">// Since VxWorks will not preempt a higher priority thread it is difficult</span>
  <span class="comment">// creating a test that will product an interesting result.</span>
  <span class="keywordtype">void</span> multiThreadedStress();
  
  <span class="comment">// Rewrite of the multithreaded test using CIMUnit</span>
  <span class="comment">//</span>
  <span class="comment">// Since VxWorks will not preempt a higher priority thread it is difficult</span>
  <span class="comment">// creating a test that will product an interesting result.</span>
  <span class="keywordtype">void</span> cimunitStressTest();
  
  <span class="comment">// White-box testing of CIMUnit used to produce an &#39;interesting&#39; schedule.</span>
  <span class="comment">// Remove the mutex&#39;s surround the operations of the stack to see this test</span>
  <span class="comment">// fail.</span>
  <span class="keywordtype">void</span> cimunitWhiteBoxTest();
};


<span class="comment">// Registers the fixture into the &#39;registry&#39;</span>
CPPUNIT_TEST_SUITE_REGISTRATION(CimunitExample);


<span class="keywordtype">void</span> CimunitExample::setUp() { }
<span class="keywordtype">void</span> CimunitExample::tearDown() { } 


<span class="keywordtype">void</span> CimunitExample::singleThreaded() {
  ThreadStack&lt;int&gt; testStack;
  
  <span class="comment">// Stack is initialized empty</span>
  CPPUNIT_ASSERT_EQUAL(<span class="keyword">true</span>, testStack.empty());
  
  <span class="comment">// Add item, verify stack isn&#39;t empty</span>
  testStack.push(100);
  CPPUNIT_ASSERT_EQUAL(<span class="keyword">false</span>, testStack.empty());
  
  <span class="comment">// Add another item.  Pop item and verify LIFO operation and that the stack</span>
  <span class="comment">// isn&#39;t empty</span>
  testStack.push(200);
  CPPUNIT_ASSERT_EQUAL(200, testStack.pop());
  CPPUNIT_ASSERT_EQUAL(<span class="keyword">false</span>, testStack.empty());
  
  <span class="comment">// Pop last item and verify the stack is now empty</span>
  CPPUNIT_ASSERT_EQUAL(100, testStack.pop());
  CPPUNIT_ASSERT_EQUAL(<span class="keyword">true</span>, testStack.empty());
}


<span class="keywordtype">void</span> stressThread(<span class="keywordtype">void</span> *param, <span class="keywordtype">int</span> delay, <span class="keywordtype">int</span> count) {
  ThreadStack&lt;int&gt; *stack = (ThreadStack&lt;int&gt; *)param;
  <span class="comment">// Loop to create lots of demand on the structure</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> a = 0; a &lt; count; ++a) {
    stack-&gt;push(a);
    <span class="comment">// Add delay to hopefully create come interesting interleavings</span>
    taskDelay(delay);
    stack-&gt;pop();
  }
}


<span class="keywordtype">void</span> CimunitExample::multiThreadedStress() {
  ThreadStack&lt;int&gt; stack;
  
  <span class="keywordtype">int</span> id1 = taskSpawn(<span class="stringliteral">&quot;stress1&quot;</span>, 100, 0, 8192, (FUNCPTR)stressThread,
                      (<span class="keywordtype">int</span>)(&amp;stack), 0, 60, 0, 0, 0, 0, 0, 0, 0);
  <span class="keywordtype">int</span> id2 = taskSpawn(<span class="stringliteral">&quot;stress2&quot;</span>, 99, 0, 8192, (FUNCPTR)stressThread,
                      (<span class="keywordtype">int</span>)(&amp;stack), 1, 10, 0, 0, 0, 0, 0, 0, 0);
  
  taskDelay(30);
  
  CPPUNIT_ASSERT_EQUAL(<span class="keyword">true</span>, stack.empty());
}


<span class="keywordtype">void</span> cimunitStressThread1(<span class="keywordtype">void</span> *param, <span class="keywordtype">int</span> delay) {
  ThreadStack&lt;int&gt; *stack = (ThreadStack&lt;int&gt; *)param;
  <span class="comment">// Loop to create lots of demand on the structure</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> a = 0; a &lt; 1000; ++a) {
    stack-&gt;push(a);
    <span class="comment">// Add delay to hopefully create come interesting interleavings</span>
    taskDelay(delay);
    stack-&gt;pop();
  }
  <a class="code" href="group__cimunit.html#gac71b8001526bea0ad3cec09dacec617e">CIMUNIT_FIRE</a>(<span class="stringliteral">&quot;cimunitStressThread1/end&quot;</span>);
}


<span class="keywordtype">void</span> cimunitStressThread2(<span class="keywordtype">void</span> *param, <span class="keywordtype">int</span> delay) {
  ThreadStack&lt;int&gt; *stack = (ThreadStack&lt;int&gt; *)param;
  <span class="comment">// Loop to create lots of demand on the structure</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> a = 0; a &lt; 1000; ++a) {
    stack-&gt;push(a);
    <span class="comment">// Add delay to hopefully create come interesting interleavings</span>
    taskDelay(delay);
    stack-&gt;pop();
  }
  <a class="code" href="group__cimunit.html#gac71b8001526bea0ad3cec09dacec617e">CIMUNIT_FIRE</a>(<span class="stringliteral">&quot;cimunitStressThread2/end&quot;</span>);
}


<span class="keywordtype">void</span> CimunitExample::cimunitStressTest() {
  ThreadStack&lt;int&gt; stack;
  
  <a name="a1"></a><a class="code" href="group__cimunit.html#ga8d5cdd678383afa1b8c0439025339887">CIMUNIT_SCHEDULE</a>(<span class="stringliteral">&quot;(cimunitStressThread1/end &amp;&amp; cimunitStressThread2/end)-&gt;testDone&quot;</span>);
  
  <span class="comment">// Two different methods are used as native thread name support hasn&#39;t been</span>
  <span class="comment">// added to VxWorks.</span>
  <span class="keywordtype">int</span> id1 = taskSpawn(<span class="stringliteral">&quot;stress1&quot;</span>, 100, 0, 8192, (FUNCPTR)cimunitStressThread1,
                      (<span class="keywordtype">int</span>)(&amp;stack), 0, 60, 0, 0, 0, 0, 0, 0, 0);
  <span class="keywordtype">int</span> id2 = taskSpawn(<span class="stringliteral">&quot;stress2&quot;</span>, 99, 0, 8192, (FUNCPTR)cimunitStressThread2,
                      (<span class="keywordtype">int</span>)(&amp;stack), 1, 10, 0, 0, 0, 0, 0, 0, 0);
  
  <span class="comment">// Event to detect when the test has been completed</span>
  <a class="code" href="group__cimunit.html#gac71b8001526bea0ad3cec09dacec617e">CIMUNIT_FIRE</a>(<span class="stringliteral">&quot;testDone&quot;</span>);
  
  <span class="comment">// Verify proper operation of the queue (the queue is empty at the end)</span>
  CPPUNIT_ASSERT_EQUAL(<span class="keyword">true</span>, stack.empty());
}


<span class="keywordtype">void</span> cimunitWhiteBoxTestThread1(<span class="keywordtype">void</span> *param) {
  ThreadStack&lt;int&gt; *stack = (ThreadStack&lt;int&gt; *)param;
  
  <span class="comment">// Add an item to the queue and then remove it</span>
  stack-&gt;push(100);
  stack-&gt;pop();
  
  <a class="code" href="group__cimunit.html#gac71b8001526bea0ad3cec09dacec617e">CIMUNIT_FIRE</a>(<span class="stringliteral">&quot;thread1Done&quot;</span>);
}


<span class="keywordtype">void</span> cimunitWhiteBoxTestThread2(<span class="keywordtype">void</span> *param1, <span class="keywordtype">void</span> *param2) {
  ThreadStack&lt;int&gt; *stack = (ThreadStack&lt;int&gt; *)param1;
  <span class="keywordtype">bool</span> *result = (<span class="keywordtype">bool</span> *)param2;

  <a class="code" href="group__cimunit.html#gac71b8001526bea0ad3cec09dacec617e">CIMUNIT_FIRE</a>(<span class="stringliteral">&quot;step1&quot;</span>);
  <span class="comment">// Check if the queue is empty</span>
  *result = stack-&gt;empty();

  <a class="code" href="group__cimunit.html#gac71b8001526bea0ad3cec09dacec617e">CIMUNIT_FIRE</a>(<span class="stringliteral">&quot;thread2Done&quot;</span>);
}


<span class="keywordtype">void</span> CimunitExample::cimunitWhiteBoxTest() {
  ThreadStack&lt;int&gt; stack;
  <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
  
  <span class="comment">// This schedule attempts to execute the ThreadStack::empty() method</span>
  <span class="comment">// while in the middle of the ThreadStack::pop() method.</span>
  <a class="code" href="group__cimunit.html#ga8d5cdd678383afa1b8c0439025339887">CIMUNIT_SCHEDULE</a>(<span class="stringliteral">&quot;TS::pop/1-&gt;step1,(thread1Done&amp;&amp;thread2Done)-&gt;testDone&quot;</span>);
  
  <span class="comment">// This thread is of a lower priority which ensures that the pop</span>
  <span class="comment">// operation isn&#39;t completed before the other thread checks if the stack</span>
  <span class="comment">// is empty.</span>
  <span class="keywordtype">int</span> id1 = taskSpawn(<span class="stringliteral">&quot;test1&quot;</span>, 100, 0, 8192, (FUNCPTR)cimunitWhiteBoxTestThread1,
                      (<span class="keywordtype">int</span>)(&amp;stack), 0, 0, 0, 0, 0, 0, 0, 0, 0);
  <span class="keywordtype">int</span> id2 = taskSpawn(<span class="stringliteral">&quot;test2&quot;</span>, 99, 0, 8192, (FUNCPTR)cimunitWhiteBoxTestThread2,
                      (<span class="keywordtype">int</span>)(&amp;stack), (<span class="keywordtype">int</span>)&amp;result, 0, 0, 0, 0, 0, 0, 0, 0);
  
  <span class="comment">// Event to detect when the test has been completed</span>
  <a class="code" href="group__cimunit.html#gac71b8001526bea0ad3cec09dacec617e">CIMUNIT_FIRE</a>(<span class="stringliteral">&quot;testDone&quot;</span>);
  
  <span class="comment">// Verify proper operation of the queue by ensuring the queue was detected</span>
  <span class="comment">// as empty.</span>
  CPPUNIT_ASSERT_EQUAL(<span class="keyword">true</span>, result);
}

</pre></div> </div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated for CIMUnit by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4</small></address>

</body>
</html>
